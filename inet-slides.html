<!DOCTYPE html>
<html>
<head>
<title>inet slides</title>
<meta charset="UTF-8">
<link rel=icon href='data:image/svg+xml,
    <svg xmlns=%22http://www.w3.org/2000/svg" viewBox="0 0 100 100">
    <text y="1.1em" font-size="75">üêåÔ∏è</text></svg>'>

<link rel="stylesheet" href="lib/katex.css">
<style>
    body {
        margin: 0;
        overflow-x: hidden;
        background-color: #eef1e5;
        font-family: "Katex_Main";
    }
    .katex { font-size: 1em; }
    .slides { transform-origin: left top; }
    x-slide {
        width: 1600px; height: 900px;
        position: relative;
        display: block;
        font-size: 32px;
    }
    x-slide:nth-child(2n) {
        background-color: #e7e9de;
    }
    x-slide h1 {
        position: absolute; left: 100px; top: 70px;
        font-size: 52px; font-weight: normal; color: #50b4c8;
    }
    x-slide pre {
        position: absolute; left: 100px; top: 220px;
        font-family: "Katex_Main"; color: #262626;
    }
    x-slide button {
        position: absolute; left: 100px; top: 220px;
        font-size: 32px; font-family: "Katex_Main"; color: #262626;
        background-color: #e9e9e9;
        border: 1px solid #ccc;
        border-radius: .5rem;
        box-sizing: border-box;
        line-height: 1.25rem;
        padding: .75rem 1rem;
        cursor: pointer;
    }
    x-slide button:hover { background-color: #ddd; }
    x-slide button:focus { outline: 2px solid #ccc; }
    .placeholder {
        background-color: #0001;
        font-size: 30px;
        text-align: center;
        align-content: center;
    }
    x-diagram div { position: absolute; }
</style>

<script defer src="lib/katex.js"></script>
<script defer src="lib/auto-render.js"></script>
<script>
addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
        delimiters: [
            { left: "$$", right: "$$", display: true },
            { left: "$", right: "$", display: false },
        ],
        throwOnError: false,
        ignoredTags: [
            "script", "noscript", "style", "textarea", "code",
            "option",
        ],
        output: "html",
    })
})

let scale = 1
onresize = () => {
    const new_scale = innerWidth / 1600
    const new_scroll = (
        window.scrollY + innerHeight / 2
    ) * new_scale / scale - innerHeight / 2 + 0.5
    scale = new_scale

    const slides = document.querySelector(".slides")
    slides.style.transform = `scale(${scale})`
    const n_slides = document.querySelectorAll("x-slide").length
    slides.style.height = `${900 * n_slides * Math.min(scale, 1)}px`

    window.scroll(0, new_scroll)
}

onload = () => {
    const _scroll = window.scrollY
    onresize()
    window.scroll(0, _scroll)

    const kvs = {}
    for (const diag of document.querySelectorAll("x-diagram")) {
        const src = diag.innerHTML.trim()
        const args_start = src.indexOf("{")
        const name = src.slice(0, args_start).trim()
        const args = parse_kvs(src.slice(args_start + 1, -1).trim())
        for (const [k, v] of Object.entries(args)) {
            kvs[k] = v
        }

        diag.style = `
            position: absolute; left: ${kvs.x}px; top: ${kvs.y}px;`
        diag.setAttribute("alt", name)
        diag.innerHTML = src.slice(src.indexOf("}") + 1).trim()
        if (diag.innerHTML === "") {
            const d = document.createElement("div")
            d.className = "placeholder"
            d.style = `
                position: absolute; left: 0px; top: 0px;
                width: ${kvs.w}px; height: ${kvs.h}px;`
            d.append(name)
            diag.append(d)
        }
    }

    init()
    loop()
}

onkeydown = e => {
    switch (e.key) {
    case "0":
        window.scrollTo({ top: 0, behavior: "smooth" }); break
    case "G":
        window.scrollTo({
            top: document.body.clientHeight - innerHeight,
            behavior: "smooth",
        }); break
    case "ArrowUp":
    case "ArrowLeft":
    case "k":
        if (!e.shiftKey && !e.altKey) {
            e.preventDefault()
            next_slide(-1)
        } break
    case "ArrowDown":
    case "ArrowRight":
    case "j":
        if (!e.shiftKey && !e.altKey) {
            e.preventDefault()
            next_slide()
        } break
    case "r": init(); break
    }
}

function parse_kvs(kv_str) {
    // convert "a: b, c: 1.23" to object
    const kv_lines = kv_str.split(",")
    const kvs = {}
    for (const kv of kv_lines) {
        if (kv.indexOf(":") === -1) continue

        let [k, v] = kv.split(":", 2)
        k = k.trim()
        v = v.trim()
        const flv = parseFloat(v)
        if (isNaN(flv)) {
            kvs[k] = v
        } else {
            kvs[k] = flv
        }
    }
    return kvs
}

function next_slide(step = 1) {
    const cur_slide = Math.floor(
        (window.scrollY + innerHeight / 2) / 900 / scale
    )
    window.scrollTo({
        top: (
            cur_slide + step + 0.5
        ) * 900 * scale - innerHeight / 2 + 0.5,
        behavior: "smooth",
    })
}
</script>
</head>

<body>
<!--
Abstract:
Our intuition for how computation should be externalized is limited by the sequential nature of
spoken language. It heavily influences our conscious strategies for evaluating and
communicating computation, and so far, its limitations have been reflected in textual languages
as well, including programming languages. Interaction nets are a visual language for
computation that can be evaluated with spatially local graph rewrites, allowing for an unbounded
degree of parallelism. They can be designed to have a deterministic result, invariant to evaluation
order of the rewrites. In this presentation, we prove the Turing completeness of interaction nets,
demonstrate parallel evaluation of structures that have nonlinear dependency graphs, such as
mathematical expressions and cellular automata, and show how the degree of parallelism can
adapt during computation.
-->

<div class="slides">

<x-slide>
<div style="
    display: flex; position: absolute; z-index: -10;
    width: 100%; height: 900px;">
    <div style="width: 6.75%; background-color: #333b45;"></div>
    <div style="width: 31.5%; background-color: #4c5967;"></div>
    <div style="width: 61.75%; background-color: #657689;"></div>
</div>

<div style="
    position: absolute; left: 700px; top: 315px; width: 600px;
    font-size: 60px; color: #fff;">
Interaction Nets and Cellular Automata</div>

<div style="
    position: absolute; left: 700px; top: 550px;
    font-size: 50px; color: #c0c8d1;">
Troy Kidd</div>

$
\gdef\tb#1{\textcolor{0070c0}{#1}}
\gdef\tr#1{\textcolor{ff0000}{#1}}
\gdef\tg#1{\textcolor{00b050}{#1}}
\gdef\tm#1{\textcolor{cc0099}{#1}}
\gdef\tp#1{\textcolor{7030a0}{#1}}
\gdef\ora#1{\overrightarrow{#1}}
$
</x-slide>


<x-slide>
<h1>Sequential Computation</h1>
<pre>
Turing machines model one computational action, at
one location, per time step.

Multi-tape Turing machines model a finite number of
computations per step, either at multiple locations or
with moving tapes.

These can do some computations in quadratically less
steps than an equivalent standard Turing machine,

but they still compute with one centralized transition
function, and constant time computation involving
indefinitely far sites is physically unrealistic.
</pre>

<x-diagram> turing machine
{ x: 990, y: 190, w: 425, h: 135 }
<svg width="425" height="135">
    <g id="g-tape" fill="none" stroke="black" stroke-width="2">
        <polygon points="180,2, 270,2, 225,65" />
        <polyline points="0,75, 420,75" />
        <polyline points="0,130, 420,130" />
        <polyline points="45,75, 45,130" />
        <polyline points="120,75, 120,130" />
        <polyline points="200,75, 200,130" />
        <polyline points="250,75, 250,130" />
        <polyline points="310,75, 310,130" />
        <polyline points="370,75, 370,130" />
    </g>
</svg>
<div style="left: 212px; top: 4px;">
    $\tr{q_0}$</div>
<div style="left: 9px; top: 82px;">
    $\tb{...} ~~~ \tb{a}_{\tg{-2}} ~~~~ \tb{a}_{\tg{-1}}
    ~~~ \tb{a}_{\tg{0}} ~~~ \tb{a}_{\tg{1}}
    ~~~~ \tb{a}_{\tg{2}} ~~~~ \tb{...}$</div>
</x-diagram>

<x-diagram> multi tape turing machine {
    y: 490, h: 290,
}
<svg width="425" height="290">
    <use xlink:href="#g-tape" />
    <use xlink:href="#g-tape" y="154" />
</svg>
<div style="left: 212px; top: 4px;">
    $\tr{q_0^{\tg{1}}}$</div>
<div style="left: 9px; top: 82px;">
    $\tb{...} ~~~ \tb{a_{\tg{-2}}^{\tg{1}}}
    ~~~~ \tb{a_{\tg{-1}}^{\tg{1}}} ~~~ \tb{a_{\tg{0}}^{\tg{1}}}
    ~~~ \tb{a_{\tg{1}}^{\tg{1}}} ~~~~ \tb{a_{\tg{2}}^{\tg{1}}}
    ~~~~ \tb{...}$</div>

<div style="left: 212px; top: 158px;">
    $\tr{q_0^{\tg{2}}}$</div>
<div style="left: 9px; top: 236px;">
    $\tb{...} ~~~ \tb{a_{\tg{-2}}^{\tg{2}}}
    ~~~~ \tb{a_{\tg{-1}}^{\tg{2}}} ~~~ \tb{a_{\tg{0}}^{\tg{2}}}
    ~~~ \tb{a_{\tg{1}}^{\tg{2}}} ~~~~ \tb{a_{\tg{2}}^{\tg{2}}}
    ~~~~ \tb{...}$</div>
</x-diagram>
</x-slide>


<x-slide>
<h1>Parallel Computation</h1>
<pre>
Interaction nets were developed by Yves Lafont in 1990,
as a practical model for parallel programming.

In this model, information is represented with a
collection of cells and ports, connected by wires.

During one computational step, if a pair of cells matches
a rule, they are replaced in a way that doesn‚Äôt leave
disconnected wires.

Many replacements can occur in parallel and can be
repeated until there are no rule matches (in the case of
a terminating computation).
</pre>

<x-diagram> interaction net { x: 960, y: 290, w: 360, h: 300 }
<svg width="360" height="300">
    <g id="g-interaction-net" stroke="black" stroke-width="2">
        <g fill="none">
            <ellipse cx="318" cy="76" rx="38" ry="38" />
            <ellipse cx="80" cy="44" rx="36" ry="40" />
        </g>
        <g fill="#64c8dc">
            <ellipse cx="220" cy="140" rx="38" ry="38" />
            <polygon points="2,50, 158,50, 80,110" />
            <polygon points="80,146, 158,206, 2,206" />
            <polygon points="80,110, 80,146" />
            <polygon points="32,206, 32,264" />
            <polygon points="80,206, 80,264" />
            <polygon points="126,206, 126,264" />
            <polygon points="220,178, 220,264" />
        </g>
    </g>
</svg>
<div style="left: 68px; top: 52px;">$\alpha$</div>
<div style="left: 68px; top: 160px;">$\beta$</div>
<div style="left: 210px; top: 118px;">$\gamma$</div>
<div style="left: 20px; top: 262px;">
    $x \quad y \quad z \qquad~ w$</div>
<pre style="left: -40px; top: 350px;">
<b>Figure 1.</b>  An interaction net
</pre>
</x-diagram>
</x-slide>


<x-slide>
<h1>Interaction Nets</h1>
<pre>
<b>Definition 1.</b>  An <i>interaction net</i> is a finite set of
labeled <i>cells</i> (each having some number of <i>ports</i>), a
set of <i>free ports</i> not associated with any cells, and a
set of <i>wires</i>, connecting each port to another one.

Cells have one <i>principal</i> port and $n \geq 0$ <i>auxiliary ports</i>
(numbered in clockwise order), where $n$ is the <i>arity</i> of
the cell‚Äôs symbol.

Wires may connect ports of the same cell or exist as a
<i>cyclic wire</i> not connecting any ports.
</pre>

<x-diagram> interaction net {}
<svg width="360" height="300">
    <use xlink:href="#g-interaction-net" />
</svg>
<div style="left: 68px; top: 52px;">$\alpha$</div>
<div style="left: 68px; top: 160px;">$\beta$</div>
<div style="left: 210px; top: 118px;">$\gamma$</div>
<div style="left: 20px; top: 262px;">
    $x \quad y \quad z \qquad~ w$</div>
<pre style="left: -40px; top: 350px;">
<b>Figure 1.</b>  An interaction net
</pre>
</x-diagram>
</x-slide>


<x-slide>
<h1>Interaction Rules</h1>
<pre>
<b>Definition 2.</b>  An <i>interaction rule</i> is a pair of interaction
nets having the same set of free ports.

The left-side net must consist of two cells with a wire
between their principal ports, and a wire between
each free port and an auxiliary port.

Rules may have more than two cells on the right,
allowing for an exponentially increasing number of
computations per step.
</pre>

<x-diagram> interaction rules { x: 1030, y: 200, w: 346, h: 450 }
<svg width="346" height="450">
    <g fill="#64c8dc" stroke="black" stroke-width="2">
        <ellipse cx="64" cy="38" rx="36" ry="36" />
        <polygon points="64,94, 120,154, 8,154" />
        <polygon points="64,74, 64,94" />
        <polygon points="34,154, 34,174" />
        <polygon points="84,154, 84,174" />

        <path fill="none"
            d="M 224 174 C 224 124, 270 124, 270 174" />

        <polygon points="10,280, 102,280, 56,344" />
        <polygon points="56,364, 108,420, 4,420" />
        <polygon points="56,344, 56,364" />
        <polygon points="56,260, 56,280" />
        <polygon points="32,420, 32,440" />
        <polygon points="82,420, 82,440" />

        <polygon points="264,280, 318,344, 210,344" />
        <polygon points="252,364, 340,364, 296,424" />
        <polygon points="264,260, 264,280" />
        <polygon points="296,344, 296,364" />
        <polygon points="296,424, 296,444" />
        <polygon points="232,344, 232,444" />
    </g>
</svg>
<div style="left: 56px; top: 20px;">$0$</div>
<div style="left: 52px; top: 106px;">$+$</div>
<div style="left: 50px; top: 282px;">$s$</div>
<div style="left: 44px; top: 376px;">$+$</div>
<div style="left: 252px; top: 298px;">$+$</div>
<div style="left: 288px; top: 366px;">$s$</div>
<div style="left: 26px; top: 172px;">
    $x \quad y \qquad \quad~~~ x \quad y$</div>
<div style="left: 148px; top: 96px;">$\rightarrow$</div>
<div style="left: 148px; top: 334px;">$\rightarrow$</div>
<pre style="left: -80px; top: 510px;">
<b>Figure 2.</b>  Two interaction rules.
The first represents inferring $y = x$ from
$y = 0 + x$.
</pre>
</x-diagram>
</x-slide>


<x-slide>
<h1>Reductions</h1>
<pre>
<b>Definition 3.</b>  A <i>reduction</i> (step) replaces a cell pair
matching the left side of a rule with the right-side net.
After identifying an active cell pair, all auxiliary ports are
temporarily treated as being wired to corresponding
free ports.

Assume that we only use rule sets that can be applied
unambiguously ‚Äì at most one rule per unordered pair
of cell symbols, and with order being irrelevant for pairs
with the same symbol.

An unambiguous rule set is called an <i>interaction system</i>.
</pre>

<x-diagram> reduction { x: 920, y: 240, w: 580, h: 360 } </x-diagram>
</x-slide>


<x-slide>
<h1>Reductions</h1>
<pre>
[hoc logo]
</pre>

<x-diagram> hoc logo { x: 430, y: 260, w: 710, h: 400 } </x-diagram>
</x-slide>


<x-slide>
<h1>Confluence</h1>
<pre>
<b>Theorem 1. (strong confluence)</b>  If an interaction net $\tb{N}$
reduces to either $\tr{P}$ or $\tg{Q}$ in one step, with $\tr{P} \neq \tg{Q}$, then $\tr{P}$
and $\tg{Q}$ can both reduce in one step to a common net $\tm{R}$.

<i>Proof.</i>  Let $\{\tr{c_1}, \tr{c_2}\}$ be the cells involved in reduction of $\tb{N}$
to $\tr{P}$, and let $\{\tg{c_3}, \tg{c_4}\}$ be the same for $\tg{Q}$.

Since reductions apply only to cell pairs connected by their
principal ports, and $\tr{P} \neq \tg{Q}$, then $\{\tr{c_1}, \tr{c_2}\} \cap \{\tg{c_3}, \tg{c_4}\} = \varnothing$.

Therefore, $\{\tg{c_3}, \tg{c_4}\}$ would remain reducible after reducing
$\{\tr{c_1}, \tr{c_2}\}$ and vice versa, so $\tm{R}$ is the net with both
reductions applied.								   $\blacksquare$
</pre>

<x-diagram> confluence { x: 940, y: 60, w: 640, h: 800 } </x-diagram>
</x-slide>


<x-slide>
<h1>Confluence</h1>
<pre>
‚ÄúStrong confluence‚Äù commonly refers only to the property
that branching reduction sequences can always result in
the same element.

It guarantees that two diverging and terminating reduction
sequences have the same result.

The version here with single step reductions additionally
guarantees that both sequences have the same length.
This is sometimes referred to as the diamond property.
</pre>

<x-diagram> confluence {} </x-diagram>
<x-diagram> diamond { x: 390, y: 700, w: 140, h: 150 } </x-diagram>
</x-slide>


<x-slide>
<h1>Expression Evaluation</h1>
<pre>
<b>Example 1.</b>  Unary addition.

Cells $0$, $s$ (successor), and $+$, along with two
interaction rules can be used reduce an addition
expression to a normal form.

From the diamond property, all possible
reductions to an irreducible form reach the same
form, with the same number of reduction steps.

In this example, an irreducible form is reached in
$4$ steps, with both rules being applied twice,
possibly in only $2$ parallel reduction passes.
</pre>

<x-diagram> unary addition { x: 790, y: 120, w: 780, h: 710 }
</x-diagram>
</x-slide>


<x-slide>
<h1>Expression Evaluation</h1>
<button onclick="init()">reset</button>

<canvas id="exp_eval_canvas" width="1600" height="900"></canvas>
</x-slide>


<x-slide>
<x-diagram> reduction paths { x: 150, y: 70, w: 1250, h: 710 }
</x-diagram>
</x-slide>


<x-slide>
<h1>Turing Completeness</h1>
<pre>
<b>Example 2.</b>  Implementation of Turing machines.

A Turing machine is formally specified with the $7$-tuple
$M = (\tr{Q}, \tb{\Gamma}, \tb{b}, \tb{\Sigma}, \tg{\delta}, \tr{q_0}, \tr{F})$, where:


$\tr{Q}$ is a set of states the machine can be in,
$\tb{\Gamma}$ is a set of symbols that can be stored on a tape,
$\tb{b} \in \tb{\Gamma}$ is the blank symbol (default if not specified),
$\tb{\Sigma} \subseteq \tb{\Gamma} \setminus \{\tb{b}\}$ is a set of valid input tape symbols,
$\tb{\delta} : (\tr{Q} \setminus \tr{F}) \times \tb{\Gamma} \rightarrow \tr{Q} \times \tb{\Gamma} \times \{\tg{L}, \tg{R}\}$ is a transition function,
$\tr{q_0} \in \tr{Q}$ is the initial state of the machine,
and $\tr{F} \subseteq \tr{Q}$ is a set of final states.
</pre>

<x-diagram> turing machine step { x: 1000, y: 290, w: 420, h: 320 }
</x-diagram>
</x-slide>


<x-slide>
<h1>Turing Completeness</h1>
<pre>
<b>Example 2 (cont‚Äôd).</b>  Implementation of Turing machines.

The primary elements are $\tr{Q}$ (states), $\tb{\Gamma}$ (symbols), and $\tg{\delta}$
(transition function). The rest are subsets or elements of
these that denote valid initial and final conditions.

Let $\tb{...}, \tb{a}_{\tg{-2}}, \tb{a}_{\tg{-1}}, \tb{a}_{\tg{0}}, \tb{a}_{\tg{1}}, \tb{a}_{\tg{2}}, \tb{...}$ denote the sequence of tape
symbols. The read/write head starts at position $\tg{0}$ and in
state $\tr{q_0}$.

If $\tg{\delta}(\tr{q}, \tb{a}) = (\tr{q'}, \tb{a'}, \tg{L})$, with $(\tr{q_0}, \tb{a}_{\tg{0}}) = (\tr{q}, \tb{a})$, then in the
next configuration, we have $\tb{a}_{\tg{0}} = \tb{a'}$ with the head at
position $\tg{-1}$ and in state $\tr{q'}$.
</pre>

<x-diagram> turing machine step {} </x-diagram>
</x-slide>


<x-slide>
<h1>Turing Completeness</h1>
<pre>
<b>Example 2 (cont‚Äôd).</b>  Implementation of Turing machines.

We can represent this configuration and transition with
the nets in Figure 7.

We orient the initial cells, and define interaction rules, so
that there is exactly one active pair at each step.
</pre>

<x-diagram> inet tm implementation { x: 900, y: 50, w: 590, h: 680 }
</x-diagram>
</x-slide>


<x-slide>
<h1>Turing Completeness</h1>
<pre>
<b>Example 2 (cont‚Äôd).</b>  Implementation of Turing machines.

If we instead initialize with $\tb{a}_{\tg{0}}$ and $\tb{a}_{\tg{1}}$ connected, the
equivalent rule for $\tg{\delta}(\tr{q}, \tb{a}) = (\tr{q'}, \tb{a'}, \tg{L})$ is different ‚Äì with
$\tr{q}$ changing $\tb{a}_{\tg{0}}$ and turning around instead of passing
through.

Since the rule depends on the last direction, we double
the size of $\tr{Q}$, so that a state $\tr{q}$ is represented with either
$\tr{q}_{\tg{L}}$ or $\tr{q}_{\tg{R}}$ depending on the previous transition (or init).

We can then match an appropriate interaction rule and
include direction info in the next state ($\color{ff0000} q_{\tg{L}}'$).
</pre>

<x-diagram> implementation with q0 coming from right {} </x-diagram>
</x-slide>


<x-slide>
<h1>Turing Completeness</h1>
<pre>
<b>Example 2 (cont‚Äôd).</b>  Implementation of Turing machines.

Since interaction nets are finite, both ends are terminated
with cells that simulate interaction with a blank symbol
and extend the tape.
</pre>

<x-diagram> a tape-extending reduction
{ x: 950, y: 130, w: 550, h: 520 }
</x-diagram>
</x-slide>


<x-slide>
<h1>Cellular Automata</h1>
<pre>
Typically, a cellular automaton (CA) is a regular network
(line/grid/etc.) of cells with discrete states.

Cells update simultaneously as a function of neighboring cells.
Each cell replaces its state with $\tg{f}(\tb{s}_{\tr{1}}, \tb{s}_{\tr{2}}, \tb{...}) \in \tb{S}$, where $\tb{s}_{\tr{i}}$ are
states of the cells in its neighborhood.

A <i>configuration</i> describes the state of all cells at some point in
time. It is considered to extend infinitely in all directions, and
can be represented as a function $\tm{c} : \tr{\mathbb{Z}}^{\tp{d}} \rightarrow \tb{S}$.
</pre>

<x-diagram> 1D and 2D CA steps { x: 1000, y: 170, w: 460, h: 490 }
</x-diagram>
</x-slide>


<x-slide>
<x-diagram> glider gun, rule 90 { x: 120, y: 150, w: 1410, h: 530 }
</x-diagram>
</x-slide>


<x-slide>
<h1>Finitely Specifiable Configurations</h1>
<pre>
<i>Finite configurations</i> consist of a finite number of cells
not in some state $\tb{s} \in \tb{S}$, with all other cells being in
state $\tb{s}$.

A configuration is <i>periodic</i> if it‚Äôs $\tr{\ora{r}}$-periodic for at least
one vector $\tr{\ora{r}} \in \tr{\mathbb{Z}}^{\tp{d}}$, meaning the state of any cell $\tr{\ora{n}}$ is
the same as cell $\tr{\ora{n}} + \tr{\ora{r}}$.

A $\tp{d}$-dimensional configuration is <i>totally periodic</i> if it‚Äôs
$\red{\ora{r_{\tp{i}}}}$-periodic for $\tp{d}$ linearly independent vectors $\red{\ora{r_{\tp{i}}}}$. For
these, the configuration can be fully described by some
finite region of cells.
</pre>

<x-diagram> finite and periodic configs
{ x: 920, y: 250, w: 610, h: 500 }
</x-diagram>
</x-slide>


<x-slide>
<h1>Cellular Automata</h1>
<pre>
<b>Example 3.</b>  Implementation of $\tp{1}$-dimensional CA.

We can implement a CA computation step with two
parallel reductions. Cells interact with their left then
right neighbor, or vice versa.

Since orientation is important here, we create a left and
right-facing version of each state.

We also add left and right-facing versions of each pair of
original states (such as $\tb{\overline{rs}}$), so reductions in the second
pass can consider both neighbors.
</pre>

<x-diagram> inet ca implementation { x: 930, y: 210, w: 540, h: 390 }
</x-diagram>
</x-slide>


<x-slide>
<h1>Cellular Automata</h1>
<x-diagram> example { x: 400, y: 190, w: 1110, h: 550 } </x-diagram>
</x-slide>


<x-slide>
<h1>Cellular Automata</h1>
<pre>
<b>Example 3 (cont‚Äôd).</b>  Implementation of 1D CA.

If we have a finite configuration (uniform state $\tb{p}$ past
some first and last cell), we can use a similar technique
as before to allow the finite net to expand indefinitely.

We can instead represent periodic configurations by
attaching both ends together, if the period is even.
</pre>

<x-diagram> config expanding reduction
{ x: 860, y: 190, w: 610, h: 400 }
</x-diagram>
<x-diagram> periodic reduction { x: 240, y: 620, w: 400, h: 260 }
</x-diagram>
</x-slide>


<x-slide>
<h1>Cellular Automata</h1>
<x-diagram> example { x: 450, y: 210, w: 1060, h: 500 } </x-diagram>
</x-slide>


<x-slide>
<h1>References</h1>
<pre>
1.  Lafont, Y. <i>Interaction Nets</i>. In Proceedings of the 17th ACM SIGPLAN-SIGACT Symposium on
Principles of Programming Languages (1989) 95-108.

2.  Lafont, Y. <i>Interaction Combinators</i>. Information and Computation, <b>137</b> no. 1 (1997), 69-101.
</pre>
</x-slide>

</div> <!-- /slides -->


<script id="math">
const pi = Math.PI
const tau = 2 * pi
const cos = Math.cos
const sin = Math.sin
const atan2 = Math.atan2
const min = Math.min
const max = Math.max
const abs = Math.abs
const floor = Math.floor
const ceil = Math.ceil
const round = Math.round
const exp = Math.exp
const log = Math.log
const rand = Math.random

const dist = (x1, y1, x2, y2) => Math.sqrt(
    (x2 - x1)**2 + (y2 - y1)**2
)
const clamp = (x, a, b) => min(max(x, a), b)
const lerp = (a, b, t) => a * (1 - t) + b * t

function lerp_angle(a, b, t) {
    const theta = b - a
    if (theta > pi) {
        a = a + tau
    } else if (theta < -pi) {
        a = a - tau
    }
    return lerp(a, b, t)
}
</script>

<script id="main">
const canvas = document.querySelector("#exp_eval_canvas")
const ctx = canvas.getContext("2d")

const now = () => performance.now()
let last_frame_time = now()

function loop() {
    const dt = (now() - last_frame_time) / 1000
    last_frame_time = now()

    update(dt)
    draw()

    requestAnimationFrame(loop)
}

function update(dt) {
    const rect = canvas.getBoundingClientRect()
    // skip if offscreen
    if (
        rect.y > innerHeight
        || rect.y + rect.height < 0
    ) { return }
    const mx = (mouse.x - rect.x) / rect.width * canvas.width
    const my = (mouse.y - rect.y) / rect.height * canvas.height

    // no big jumps if fps < 10
    dt = min(dt, 0.1)

    // influence cell velocities to shorten primary wires,
    // apply rewrite if short enough
    for (const edge of edges) {
        // skip if not a primary port/port edge
        if (
            edge[0].type === "cell" 
            || !(edge[0].label === 0 && edge[1].label === 0)
        ) continue

        // primary plus mouse close
        const rect = canvas.getBoundingClientRect()
        const mx = (mouse.x - rect.x) / rect.width * canvas.width
        const my = (mouse.y - rect.y) / rect.height * canvas.height
        const md = dist(
            mx, my,
            (edge[0].x + edge[1].x) / 2,
            (edge[0].y + edge[1].y) / 2,
        )
        if (edge.is_primary && md < 200) {
            let [c1, c2] = edge.cells
            const dx = c2.x - c1.x
            const dy = c2.y - c1.y
            const accel = 20 * max((200 - md) / 200, 0)
            c1.xv += dx * accel * dt
            c1.yv += dy * accel * dt
            c2.xv -= dx * accel * dt
            c2.yv -= dy * accel * dt

            const d = dist(c1.x, c1.y, c2.x, c2.y)
            if (d < 10) {
                let rule = null
                for (test_rule of rules) {
                    if (
                        c1.label === test_rule.match[0]
                        && c2.label === test_rule.match[1]
                        || c2.label === test_rule.match[0]
                        && c1.label === test_rule.match[1] 
                    ) {
                        rule = test_rule
                        break
                    }
                }
                if (rule !== null) {
                    // match order
                    if (c1.label !== rule.match[0]) {
                        [c1, c2] = [c2, c1]
                    }

                    // add aux ports to list
                    const rule_ports = []
                    for (let i = 1; i < c1.ports.length; i++) {
                        rule_ports.push({port: c1.ports[i]})
                    }
                    for (let i = 1; i < c2.ports.length; i++) {
                        rule_ports.push({port: c2.ports[i]})
                    }

                    // remove cells and primary wire
                    for (let i = verts.length - 1; i >= 0; i--) {
                        if (verts[i] === c1 || verts[i] === c2) {
                            verts.splice(i, 1)
                        }
                    }
                    for (let i = 0; i < edges.length; i++) {
                        if (
                            edges[i].cells && (
                                edges[i].cells[0] === c1
                                && edges[i].cells[1] === c2
                                || edges[i].cells[1] === c1
                                && edges[i].cells[0] === c2
                            )
                        ) {
                            edges.splice(i, 1)
                            break
                        }
                    }

                    // add new cells and add ports to list
                    const match_angle = atan2(
                        c1.y - c2.y, c1.x - c2.x
                    )
                    const cx = (c1.x + c2.x) / 2
                    const cy = (c1.y + c2.y) / 2
                    for (const nc of rule.new_cells) {
                        const a = match_angle + nc.angle
                        const c = new_cell(
                            nc.label,
                            cx + cos(a) * nc.x - sin(a) * nc.y,
                            cy + sin(a) * nc.x + cos(a) * nc.y,
                            a,
                        )
                        for (let i = 0; i < c.ports.length; i++) {
                            rule_ports.push({
                                port: c.ports[i], cell: c
                            })
                        }
                    }

                    // add new wires
                    for (const port_ids of rule.wires) {
                        const rp1 = rule_ports[port_ids[0]]
                        const rp2 = rule_ports[port_ids[1]]
                        const new_wire = {
                            0: rp1.port, 1: rp2.port, cells: []
                        }
                        if (rp1.cell) new_wire.cells.push(rp1.cell)
                        if (rp2.cell) new_wire.cells.push(rp2.cell)
                        if (
                            new_wire.cells.length === 2
                            && rp1.cell.ports[0] === rp1.port
                            && rp2.cell.ports[0] === rp2.port
                        ) {
                            new_wire.is_primary = true
                        }
                        edges.push(new_wire)
                    }
                }
            } 
        }
    }

    // remove center port in (cell - port - port - port - cell) paths
    // and possibly set wire as primary
    for (let e_idx = edges.length - 1; e_idx >= 0; e_idx--) {
        const edge = edges[e_idx]
        const p1 = edge[0]
        const p2 = edge[1]
        if (!(p1.type === "port" && p2.type === "port")) continue

        let p1_next = null
        let p2_next = null
        for (const edge2 of edges) {
            if (edge2[0] === p1 && edge2[1] !== p2)
                p1_next = edge2[1]
            if (edge2[1] === p1 && edge2[0] !== p2)
                p1_next = edge2[0]
            if (edge2[0] === p2 && edge2[1] !== p1)
                p2_next = edge2[1]
            if (edge2[1] === p2 && edge2[0] !== p1)
                p2_next = edge2[0]
        }
        if (!(p1_next && p2_next)) continue

        if (p1_next.type === "cell" && p2_next.type === "port") {
            // remove p2 and adjacent edges,
            // then connect p1 and p2_next
            for (let i = verts.length - 1; i >= 0; i--) {
                if (verts[i] === p2) verts.splice(i, 1)
            }
            for (let i = edges.length - 1; i >= 0; i--) {
                if (edges[i][0] === p2 || edges[i][1] === p2) {
                    edges.splice(i, 1)
                }
            }
            let p2_next_2 = null
            for (const edge3 of edges) {
                if (edge3[0] === p2_next && edge3[1] !== p2)
                    p2_next_2 = edge3[1]
                if (edge3[1] === p2_next && edge3[0] !== p2)
                    p2_next_2 = edge3[0]
            }

            const new_wire = {
                0: p1, 1: p2_next, cells: [p1_next]
            }
            if (p2_next_2 && p2_next_2.type === "cell") {
                new_wire.cells.push(p2_next_2)
            }
            if (
                new_wire.cells.length === 2
                && p1_next.ports[0] === p1
                && p2_next_2.ports[0] === p2_next
            ) {
                new_wire.is_primary = true
            }
            edges.push(new_wire)
        }
        // do it all over again but if p2_next is cell
        if (p1_next.type === "port" && p2_next.type === "cell") {
            // remove p1 and adjacent edges,
            // then connect p1_next and p2
            for (let i = verts.length - 1; i >= 0; i--) {
                if (verts[i] === p1) verts.splice(i, 1)
            }
            for (let i = edges.length - 1; i >= 0; i--) {
                if (edges[i][0] === p1 || edges[i][1] === p1) {
                    edges.splice(i, 1)
                }
            }
            let p1_next_2 = null
            for (const edge3 of edges) {
                if (edge3[0] === p1_next && edge3[1] !== p1)
                    p1_next_2 = edge3[1]
                if (edge3[1] === p1_next && edge3[0] !== p1)
                    p1_next_2 = edge3[0]
            }

            const new_wire = {
                0: p1_next, 1: p2, cells: [p2_next]
            }
            if (p1_next_2 && p1_next_2.type === "cell") {
                new_wire.cells.push(p1_next_2)
            }
            if (
                new_wire.cells.length === 2
                && p1_next_2.ports[0] === p1_next
                && p2_next.ports[0] === p2
            ) {
                new_wire.is_primary = true
            }
            edges.push(new_wire)
        }
    }

    // update cells
    for (const vert of verts) {
        if (vert.type === "cell") update_cell(vert, dt)
    }
}

function draw() {
    const rect = canvas.getBoundingClientRect()
    // skip if offscreen
    if (
        rect.y > innerHeight
        || rect.y + rect.height < 0
    ) { return }
    const mx = (mouse.x - rect.x) / rect.width * canvas.width
    const my = (mouse.y - rect.y) / rect.height * canvas.height

    ctx.clearRect(0, 0, canvas.width, canvas.height)

    // line style
    ctx.strokeStyle = "#000"
    ctx.lineCap = "round"
    ctx.lineJoin = "round"
    ctx.lineWidth = 2

    // font style
    ctx.font = "32px Katex_Main"
    ctx.textAlign = "center"
    ctx.textBaseline = "middle"

    // cells/free ports
    for (vert of verts) {
        if (vert.type === "cell") draw_cell(vert)
        else if (vert.free) {
            // free port
            ctx.fillStyle = "#000"
            const _mat = ctx.getTransform()
            ctx.translate(vert.x, vert.y)
            ctx.rotate(vert.angle)
            ctx.translate(-15, 0)
            ctx.rotate(-vert.angle)
            ctx.fillText(vert.label, 0, 0)

            ctx.setTransform(_mat)
        }
    }

    // wires
    for (const edge of edges) {
        // (if not a cell -> port edge)
        if (edge[0].type !== "cell") draw_wire(edge)
    }

    // mouse circle
    ctx.fillStyle = "#000"
    // fade in as mouse enters slide
    ctx.globalAlpha = 0.05 * clamp(
        (450 - abs(my - 450)) / 200,
        0, 1
    )
    ctx.beginPath()
    ctx.arc(mx, my, 200, 0, tau)
    ctx.fill()
    ctx.globalAlpha = 1
}
</script>

<script id="controls">
const mouse = {
    x: 0, y: 0,
    held: { 0: false, 1: false, 2: false },
}

function mouse_held(button) {
    if (button === undefined) {
        for (const b in mouse.held) {
            if (mouse.held[b]) {
                return true
            }
        }
        return false
    }
    return button in mouse.held && mouse.held[button]
}

onpointermove = e => {
    if (!e.isPrimary) return
    mouse.x = e.clientX
    mouse.y = e.clientY
}
onpointerdown = e => {
    if (!e.isPrimary) return
    if (e.button in mouse.held) {
        mouse.held[e.button] = true
    }
    mouse.x = e.clientX
    mouse.y = e.clientY
}
onpointerup = e => {
    if (!e.isPrimary) return
    if (e.button in mouse.held) {
        mouse.held[e.button] = false
    }
}
</script>


<script id="inet_def">
function init() {
    // free ports
    const port_x = {
        type: "port", free: true, label: "x",
        x: 200, y: 300, angle: -pi / 2,
    }
    const port_y = {
        type: "port", free: true, label: "y",
        x: 300, y: 300, angle: -pi / 2,
    }
    const port_z = {
        type: "port", free: true, label: "z",
        x: 750, y: 450, angle: -pi / 2,
    }
    verts = [port_x, port_y, port_z]

    edges = []

    // cells (adds to edges)
    const c0 = new_cell("0", 250, 100, pi / 2)
    const cplus = new_cell("+", 250, 200, -pi / 2)

    const c01 = new_cell("0", 450, 100, pi / 2)
    const c02 = new_cell("0", 600, 100, pi / 2)
    const c03 = new_cell("0", 750, 100, pi / 2)
    const cs1 = new_cell("s", 450, 200, pi / 2)
    const cs2 = new_cell("s", 600, 200, pi / 2)
    const cs3 = new_cell("s", 750, 200, pi / 2)
    const cplus2 = new_cell("+", 600, 300, -pi / 2)
    const cplus3 = new_cell("+", 750, 300, -pi / 2)

    // shift vert positions
    for (const v of verts) {
        v.x += 260
        v.y += 260
    }

    // wires
    edges.push({
        0: c0.ports[0], 1: cplus.ports[0], cells: [c0, cplus],
        is_primary: true,
    })
    edges.push(
        {0: cplus.ports[2], 1: port_x, cells: [cplus]}
    )
    edges.push({0: cplus.ports[1], 1: port_y})

    edges.push({
        0: c01.ports[0], 1: cs1.ports[1], cells: [c01, cs1]
    })
    edges.push({
        0: c02.ports[0], 1: cs2.ports[1], cells: [c02, cs2]
    })
    edges.push({
        0: c03.ports[0], 1: cs3.ports[1], cells: [c03, cs3]
    })
    edges.push({
        0: cs2.ports[0], 1: cplus2.ports[0], cells: [cs2, cplus2],
        is_primary: true,
    })
    edges.push({
        0: cs3.ports[0], 1: cplus3.ports[0], cells: [cs3, cplus3],
        is_primary: true,
    })
    edges.push({
        0: cs1.ports[0], 1: cplus2.ports[2], cells: [cs1, cplus2]
    })
    edges.push({
        0: cplus2.ports[1], 1: cplus3.ports[2],
        cells: [cplus2, cplus3],
    })
    edges.push({
        0: cplus3.ports[1], 1: port_z, cells: [cplus3, port_z]
    })

    // rules
    rules = [
        {
            match: ["0", "+"],
            new_cells: [],
            wires: [[0, 1]],
        },
        {
            match: ["s", "+"],
            new_cells: [
                {label: "+", x: 80, y: 0, angle: 0},
                {label: "s", x: 80, y: -40, angle: pi},
            ],
            wires: [
                [0, 3],
                [1, 6],
                [2, 5],
                [4, 7],
            ]
        }
    ]
}
</script>

<script id="inet_sim">
// label -> n_ports
const cell_types = {
    "0": 1,
    "s": 2,
    "+": 3,
}

function new_cell(label, x, y, angle) {
    // add cell
    const cell = {type: "cell", label, x, y, angle, xv: 0, yv: 0}
    verts.push(cell)

    // construct cell ports
    cell.ports = []
    cell.ports.push({type: "port", label: 0, x, y, angle})
    const n_ports = cell_types[label]
    for (let i = 1; i < n_ports; i++) {
        const dx = -60
        const dy = (
            n_ports === 2 ? 0 : 30 - 60 * (i - 1) / (n_ports - 2)
        )
        cell.ports.push({
            type: "port",
            label: i,
            x: cell.x + cos(cell.angle) * dx - sin(cell.angle) * dy,
            y: cell.y + sin(cell.angle) * dx + cos(cell.angle) * dy,
            angle: cell.angle + pi,
        })
    }
    // add/connect cell ports
    for (const pv of cell.ports) {
        verts.push(pv)
        edges.push([cell, pv])
    }

    return cell
}

function update_cell(cell, dt) {
    // some random movement
    cell.xv += (rand() * 2 - 1) * 200 * dt
    cell.yv += (rand() * 2 - 1) * 200 * dt

    // slow down
    cell.xv *= exp(log(0.01) * dt)
    cell.yv *= exp(log(0.01) * dt)

    // apply vel
    cell.x += cell.xv * dt
    cell.y += cell.yv * dt

    // align towards primary port connection
    const p0 = cell.ports[0]
    let p0_next = null
    for (const edge of edges) {
        // skip if not a port/port edge involving primary
        if (
            edge[0].type === "cell" 
            || !(edge[0].label === 0 || edge[1].label == 0)
        ) continue

        if (edge[0] === p0) p0_next = edge[1]
        if (edge[1] === p0) p0_next = edge[0]
    }
    if (p0_next) {
        const a = atan2(p0_next.y - p0.y, p0_next.x - p0.x)
        cell.angle = lerp_angle(cell.angle, a, 2 * dt)
    }

    // update port positions/angles
    cell.ports[0].x = cell.x
    cell.ports[0].y = cell.y
    cell.ports[0].angle = cell.angle
    const n_ports = cell_types[cell.label]
    for (let i = 1; i < cell.ports.length; i++) {
        const dx = -60
        const dy = (
            n_ports === 2 ? 0 : 30 - 60 * (i - 1) / (n_ports - 2)
        )
        cell.ports[i].x = (
            cell.x + cos(cell.angle) * dx - sin(cell.angle) * dy
        )
        cell.ports[i].y = (
            cell.y + sin(cell.angle) * dx + cos(cell.angle) * dy
        )
        cell.ports[i].angle = cell.angle + pi
    }
}
</script>

<script id="inet_draw">
function draw_cell(cell) {
    const _mat = ctx.getTransform()
    ctx.translate(cell.x, cell.y)
    ctx.rotate(cell.angle)

    ctx.fillStyle = "#64c8dc"
    if (cell.ports.length === 1) {
        // circle
        ctx.beginPath()
        ctx.arc(-30, 0, 30, 0, tau)
        ctx.fill()
        ctx.stroke()

        ctx.fillStyle = "#000"
        ctx.translate(-30, 0)
        ctx.rotate(-cell.angle)
        ctx.fillText(cell.label, 0, 0)
    } else {
        // triangle
        ctx.beginPath()
        ctx.moveTo(0, 0)
        ctx.lineTo(-60, 50)
        ctx.lineTo(-60, -50)
        ctx.closePath()
        ctx.fill()
        ctx.stroke()

        ctx.fillStyle = "#000"
        ctx.translate(-40, 0)
        ctx.rotate(-cell.angle)
        ctx.fillText(cell.label, 0, 0)
    }

    ctx.setTransform(_mat)
}

function draw_wire(wire) {
    const p1 = wire[0]
    const p2 = wire[1]
    let a1 = p1.angle
    let a2 = p2.angle

    // if transient port wire, flip angles
    let p1_next = null
    let p2_next = null
    for (const edge of edges) {
        if (edge[0] === p1 && edge[1] !== p2) p1_next = edge[1]
        if (edge[1] === p1 && edge[0] !== p2) p1_next = edge[0]
        if (edge[0] === p2 && edge[1] !== p1) p2_next = edge[1]
        if (edge[1] === p2 && edge[0] !== p1) p2_next = edge[0]
    }
    if (
        p1_next && p2_next
        && p1_next.type === "port" && p2_next.type === "port"
    ) {
        a1 += pi
        a2 += pi
    }

    // draw
    ctx.beginPath()
    ctx.moveTo(p1.x, p1.y)
    const d = dist(p1.x, p1.y, p2.x, p2.y)
    const curve_d = min(d / 2, 100)
    ctx.bezierCurveTo(
        p1.x + cos(a1) * curve_d,
        p1.y + sin(a1) * curve_d,
        p2.x + cos(a2) * curve_d,
        p2.y + sin(a2) * curve_d,
        p2.x, p2.y
    )
    ctx.stroke()
}
</script>

</body>
</html>